/**
 * Task Lifecycle Funnel - Calculate conversion funnel for task lifecycle stages
 *
 * Tracks tasks through their lifecycle:
 * Generated → Engaged → Approved → Completed
 *                    ↘ Dismissed
 *
 * "Engaged" means the task was interacted with (approved, dismissed, or completed)
 */

import { loadTasks } from './task-store.mjs';

/**
 * Calculate task lifecycle funnel for a given time period
 *
 * @param {Object} options - Query options
 * @param {number} options.daysBack - Number of days to look back (default: 7)
 * @returns {Promise<Object>} Funnel data with counts and conversion rates
 */
export async function calculateFunnel(options = {}) {
  const { daysBack = 7 } = options;

  // Load all tasks
  const allTasks = await loadTasks();

  // Filter tasks to time window
  const cutoffDate = new Date();
  cutoffDate.setDate(cutoffDate.getDate() - daysBack);

  const tasksInWindow = allTasks.filter(task => {
    const taskDate = new Date(task.generatedAt || task.savedAt);
    return taskDate >= cutoffDate;
  });

  // Calculate stage counts
  const counts = {
    generated: tasksInWindow.length,
    engaged: 0,      // Tasks that were interacted with (approved, dismissed, or completed)
    approved: 0,     // Tasks with status "approved" or "completed"
    completed: 0,    // Tasks with status "completed"
    dismissed: 0,    // Tasks with status "dismissed"
  };

  // Count by status
  for (const task of tasksInWindow) {
    const status = task.status;

    if (status === 'approved' || status === 'completed' || status === 'dismissed') {
      counts.engaged++;
    }

    if (status === 'approved' || status === 'completed') {
      counts.approved++;
    }

    if (status === 'completed') {
      counts.completed++;
    }

    if (status === 'dismissed') {
      counts.dismissed++;
    }
  }

  // Calculate conversion rates (as percentages)
  const rates = {
    generatedToEngaged: counts.generated > 0 ? (counts.engaged / counts.generated) * 100 : 0,
    engagedToApproved: counts.engaged > 0 ? (counts.approved / counts.engaged) * 100 : 0,
    approvedToCompleted: counts.approved > 0 ? (counts.completed / counts.approved) * 100 : 0,
    engagedToDismissed: counts.engaged > 0 ? (counts.dismissed / counts.engaged) * 100 : 0,
  };

  // Calculate percentages of total generated
  const percentages = {
    generated: 100,
    engaged: counts.generated > 0 ? (counts.engaged / counts.generated) * 100 : 0,
    approved: counts.generated > 0 ? (counts.approved / counts.generated) * 100 : 0,
    completed: counts.generated > 0 ? (counts.completed / counts.generated) * 100 : 0,
    dismissed: counts.generated > 0 ? (counts.dismissed / counts.generated) * 100 : 0,
  };

  // Identify drop-off points (stages with < 50% conversion)
  const dropoffs = [];
  if (rates.generatedToEngaged < 50) {
    dropoffs.push({
      stage: 'generated_to_engaged',
      rate: rates.generatedToEngaged,
      description: `Only ${rates.generatedToEngaged.toFixed(1)}% of generated tasks are being engaged with`,
    });
  }
  if (rates.engagedToApproved < 50) {
    dropoffs.push({
      stage: 'engaged_to_approved',
      rate: rates.engagedToApproved,
      description: `Only ${rates.engagedToApproved.toFixed(1)}% of engaged tasks are being approved`,
    });
  }
  if (rates.approvedToCompleted < 50) {
    dropoffs.push({
      stage: 'approved_to_completed',
      rate: rates.approvedToCompleted,
      description: `Only ${rates.approvedToCompleted.toFixed(1)}% of approved tasks are being completed`,
    });
  }

  return {
    period: {
      daysBack,
      startDate: cutoffDate.toISOString(),
      endDate: new Date().toISOString(),
      totalTasks: tasksInWindow.length,
    },
    stages: {
      generated: {
        count: counts.generated,
        percentage: percentages.generated,
        description: 'Tasks generated by analyzers',
      },
      engaged: {
        count: counts.engaged,
        percentage: percentages.engaged,
        description: 'Tasks that received user action (approved or dismissed)',
      },
      approved: {
        count: counts.approved,
        percentage: percentages.approved,
        description: 'Tasks approved for implementation',
      },
      completed: {
        count: counts.completed,
        percentage: percentages.completed,
        description: 'Tasks fully completed',
      },
      dismissed: {
        count: counts.dismissed,
        percentage: percentages.dismissed,
        description: 'Tasks dismissed (not pursued)',
      },
    },
    conversionRates: {
      generatedToEngaged: {
        rate: rates.generatedToEngaged,
        description: 'Percentage of generated tasks that receive user action',
      },
      engagedToApproved: {
        rate: rates.engagedToApproved,
        description: 'Percentage of engaged tasks that are approved (vs dismissed)',
      },
      approvedToCompleted: {
        rate: rates.approvedToCompleted,
        description: 'Percentage of approved tasks that are completed',
      },
      engagedToDismissed: {
        rate: rates.engagedToDismissed,
        description: 'Percentage of engaged tasks that are dismissed',
      },
    },
    dropoffs,
    summary: {
      healthScore: calculateHealthScore(rates),
      topIssue: dropoffs.length > 0 ? dropoffs[0].description : 'No major drop-off points detected',
      recommendation: generateRecommendation(counts, rates),
    },
  };
}

/**
 * Calculate overall funnel health score (0-100)
 *
 * @param {Object} rates - Conversion rates
 * @returns {number} Health score
 */
function calculateHealthScore(rates) {
  // Weight different stages
  const weights = {
    generatedToEngaged: 0.3,   // 30% weight - getting users to look at tasks
    engagedToApproved: 0.3,    // 30% weight - getting approval vs dismissal
    approvedToCompleted: 0.4,  // 40% weight - getting tasks done
  };

  const score =
    rates.generatedToEngaged * weights.generatedToEngaged +
    rates.engagedToApproved * weights.engagedToApproved +
    rates.approvedToCompleted * weights.approvedToCompleted;

  return Math.round(score);
}

/**
 * Generate actionable recommendation based on funnel data
 *
 * @param {Object} counts - Stage counts
 * @param {Object} rates - Conversion rates
 * @returns {string} Recommendation text
 */
function generateRecommendation(counts, rates) {
  // No tasks generated
  if (counts.generated === 0) {
    return 'No tasks generated in this period. Ensure analyzers are running.';
  }

  // Low engagement (< 30%)
  if (rates.generatedToEngaged < 30) {
    return 'Many tasks are not being reviewed. Consider reducing task volume or improving task quality/relevance.';
  }

  // High dismissal rate (> 60%)
  if (counts.engaged > 0 && (counts.dismissed / counts.engaged) > 0.6) {
    return 'High dismissal rate detected. Review task generation criteria to improve relevance.';
  }

  // Low approval-to-completion rate (< 40%)
  if (rates.approvedToCompleted < 40 && counts.approved > 5) {
    return 'Many approved tasks are not being completed. Consider breaking down tasks or simplifying implementation.';
  }

  // High engagement but low approval
  if (rates.generatedToEngaged > 60 && rates.engagedToApproved < 50) {
    return 'Tasks are being reviewed but not approved. Focus on improving task quality and confidence scores.';
  }

  // Good overall health
  if (rates.generatedToEngaged > 60 && rates.engagedToApproved > 60 && rates.approvedToCompleted > 60) {
    return 'Funnel is healthy! Keep up the current task generation and workflow practices.';
  }

  // Default
  return 'Monitor funnel metrics and adjust task generation as needed.';
}

/**
 * Calculate funnel trends over time
 *
 * @param {Array<number>} daysBackPeriods - Array of day periods to compare (e.g., [7, 14, 30])
 * @returns {Promise<Object>} Trend data showing changes over time
 */
export async function calculateFunnelTrends(daysBackPeriods = [7, 14, 30]) {
  const funnels = await Promise.all(
    daysBackPeriods.map(days => calculateFunnel({ daysBack: days }))
  );

  const trends = {
    periods: daysBackPeriods,
    data: funnels,
    changes: [],
  };

  // Calculate period-over-period changes
  for (let i = 1; i < funnels.length; i++) {
    const current = funnels[i - 1];
    const previous = funnels[i];

    trends.changes.push({
      period: `${daysBackPeriods[i - 1]} vs ${daysBackPeriods[i]} days`,
      healthScoreChange: current.summary.healthScore - previous.summary.healthScore,
      engagementChange: current.conversionRates.generatedToEngaged.rate - previous.conversionRates.generatedToEngaged.rate,
      approvalChange: current.conversionRates.engagedToApproved.rate - previous.conversionRates.engagedToApproved.rate,
      completionChange: current.conversionRates.approvedToCompleted.rate - previous.conversionRates.approvedToCompleted.rate,
    });
  }

  return trends;
}

export default {
  calculateFunnel,
  calculateFunnelTrends,
};
