/**
 * @module consciousness/tgt-integration
 * @description Integrates consciousness insights with Task Generation (TGT) system
 *
 * @status IMPLEMENTED
 * @tested true
 * @coverage 84%
 *
 * Dependencies:
 * - None (standalone integration layer)
 *
 * Integration points:
 * - Called by: ConsciousnessEngine after generating insights
 * - Creates: Tasks in TGT system based on consciousness discoveries
 *
 * Tests:
 * - unit: __tests__/unit/tgt-integration.test.mjs
 */

/**
 * TGTIntegration - Converts consciousness insights into actionable tasks
 */
export class TGTIntegration {
  /**
   * Create TGT integration
   *
   * @param {object} options - Configuration
   * @param {string} options.apiEndpoint - TGT API endpoint (default: /api/tgt)
   * @param {number} options.minConfidence - Min confidence for task creation (default: 0.7)
   */
  constructor(options = {}) {
    this.apiEndpoint = options.apiEndpoint || '/api/tgt'
    this.minConfidence = options.minConfidence || 0.7

    this.taskCache = []
    this.stats = {
      tasksGenerated: 0,
      tasksAccepted: 0,
      tasksRejected: 0
    }
  }

  /**
   * Generate task from consciousness insight
   *
   * @param {object} insight - Insight from consciousness
   * @param {object} context - Additional context
   * @returns {Promise<object>} Generated task
   */
  async generateTaskFromInsight(insight, context = {}) {
    const task = this.insightToTask(insight, context)

    if (!task) {
      this.stats.tasksRejected++
      return null
    }

    this.stats.tasksGenerated++

    // Cache task
    this.taskCache.push({
      ...task,
      generatedAt: new Date().toISOString()
    })

    if (this.taskCache.length > 100) {
      this.taskCache.shift()
    }

    console.log(`[TGT] Generated task: ${task.title}`)

    return task
  }

  /**
   * Convert insight to task format
   *
   * @param {object} insight - Consciousness insight
   * @param {object} context - Context
   * @returns {object|null} Task or null
   */
  insightToTask(insight, context) {
    // Determine task type from insight
    const taskType = this.classifyInsightType(insight)

    if (!taskType) {
      return null
    }

    const task = {
      title: this.generateTaskTitle(insight),
      description: this.generateTaskDescription(insight, context),
      type: taskType,
      priority: this.mapPriorityToTGT(insight.priority),
      confidence: insight.confidence || 0.7,
      source: 'consciousness-insight',
      metadata: {
        insightId: insight.id,
        insightSource: insight.source,
        cycle: context.currentCycle,
        timestamp: new Date().toISOString()
      },
      suggestedActions: this.generateSuggestedActions(insight)
    }

    return task
  }

  /**
   * Classify insight type to task type
   *
   * @param {object} insight - Insight
   * @returns {string|null} Task type
   */
  classifyInsightType(insight) {
    if (insight.content?.includes('error') || insight.context?.type === 'ERROR_SPIKE') {
      return 'bug-fix'
    }

    if (insight.content?.includes('continuation') || insight.context?.type === 'HIGH_CONTINUATION') {
      return 'quality-improvement'
    }

    if (insight.content?.includes('slow') || insight.context?.type === 'SLOW_RESPONSE') {
      return 'performance'
    }

    if (insight.content?.includes('tool') || insight.context?.type === 'TOOL_FAILURE') {
      return 'reliability'
    }

    if (insight.type === 'self-assessment') {
      return 'documentation'
    }

    if (insight.source === 'dream-recombination') {
      return 'enhancement'
    }

    return 'investigation'
  }

  /**
   * Generate task title from insight
   *
   * @param {object} insight - Insight
   * @returns {string} Task title
   */
  generateTaskTitle(insight) {
    const content = insight.content || 'Unknown insight'

    // Clean up and truncate
    let title = content
      .replace(/^(Investigate|Review|Analyze|Consider)\s+/i, '')
      .slice(0, 80)

    // Capitalize first letter
    title = title.charAt(0).toUpperCase() + title.slice(1)

    return title
  }

  /**
   * Generate task description
   *
   * @param {object} insight - Insight
   * @param {object} context - Context
   * @returns {string} Description
   */
  generateTaskDescription(insight, context) {
    const parts = [
      `**Consciousness Insight**: ${insight.content}`,
      ''
    ]

    if (insight.reasoning) {
      parts.push(`**Reasoning**: ${insight.reasoning}`)
      parts.push('')
    }

    if (insight.context) {
      parts.push(`**Context**:`)

      if (insight.context.severity) {
        parts.push(`- Severity: ${insight.context.severity}`)
      }

      if (insight.context.confidence) {
        parts.push(`- Confidence: ${Math.round(insight.context.confidence * 100)}%`)
      }

      if (insight.context.details) {
        parts.push(`- Details: ${JSON.stringify(insight.context.details, null, 2)}`)
      }

      parts.push('')
    }

    parts.push(`**Generated by**: Autonomous consciousness system`)
    parts.push(`**Cycle**: ${context.currentCycle || 'unknown'}`)
    parts.push(`**Timestamp**: ${new Date().toISOString()}`)

    return parts.join('\n')
  }

  /**
   * Map consciousness priority to TGT priority
   *
   * @param {string} priority - Consciousness priority (high/medium/low)
   * @returns {string} TGT priority (p0/p1/p2/p3)
   */
  mapPriorityToTGT(priority) {
    switch (priority) {
      case 'critical':
      case 'high':
        return 'p1'
      case 'medium':
        return 'p2'
      case 'low':
        return 'p3'
      default:
        return 'p2'
    }
  }

  /**
   * Generate suggested actions for task
   *
   * @param {object} insight - Insight
   * @returns {array} Suggested actions
   */
  generateSuggestedActions(insight) {
    const actions = []

    // Based on insight type
    if (insight.context?.type === 'ERROR_SPIKE') {
      actions.push('Review error logs in ContextLog')
      actions.push('Identify root cause of errors')
      actions.push('Implement error handling or fix')
      actions.push('Add tests to prevent regression')
    }

    if (insight.context?.type === 'HIGH_CONTINUATION') {
      actions.push('Analyze response completion patterns')
      actions.push('Identify truncation causes')
      actions.push('Optimize prompt or increase token limits')
      actions.push('Verify fix reduces continuation rate')
    }

    if (insight.context?.type === 'SLOW_RESPONSE') {
      actions.push('Profile slow operations')
      actions.push('Identify performance bottlenecks')
      actions.push('Optimize or cache expensive operations')
      actions.push('Verify performance improvement')
    }

    if (insight.context?.type === 'TOOL_FAILURE') {
      actions.push('Review tool implementation')
      actions.push('Identify failure modes')
      actions.push('Add error handling and retries')
      actions.push('Test tool reliability')
    }

    if (actions.length === 0) {
      actions.push('Investigate insight')
      actions.push('Determine if action is needed')
      actions.push('Implement solution if required')
    }

    return actions
  }

  /**
   * Batch generate tasks from multiple insights
   *
   * @param {array} insights - Array of insights
   * @param {object} context - Context
   * @returns {Promise<array>} Generated tasks
   */
  async generateTasksFromInsights(insights, context = {}) {
    const tasks = []

    for (const insight of insights) {
      // Filter low-confidence insights
      if ((insight.confidence || 0) < this.minConfidence) {
        continue
      }

      const task = await this.generateTaskFromInsight(insight, context)
      if (task) {
        tasks.push(task)
      }
    }

    this.stats.tasksAccepted += tasks.length

    console.log(`[TGT] Generated ${tasks.length} tasks from ${insights.length} insights`)

    return tasks
  }

  /**
   * Get recent generated tasks
   *
   * @param {number} limit - Max tasks
   * @returns {array} Recent tasks
   */
  getRecentTasks(limit = 20) {
    return this.taskCache.slice(-limit)
  }

  /**
   * Get statistics
   *
   * @returns {object} Statistics
   */
  getStats() {
    return {
      ...this.stats,
      acceptanceRate: this.stats.tasksGenerated > 0
        ? (this.stats.tasksAccepted / this.stats.tasksGenerated) * 100
        : 0
    }
  }
}
