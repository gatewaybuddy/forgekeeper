/**
 * Decision Artifact Generator
 *
 * Generates persistent artifacts for key decisions made during autonomous execution.
 * Tracks decision rationale, alternatives considered, and outcomes for future reference.
 *
 * Decision Types:
 * - Alternative selection (from proactive planning)
 * - Risk-based approvals
 * - Recovery strategy selection
 * - Confidence-based checkpoints
 *
 * @module server/automation/decision-artifacts
 */

import fs from 'fs/promises';
import path from 'path';
import { ulid } from 'ulid';

/**
 * Generate a decision artifact
 *
 * @param {Object} decision - Decision data
 * @param {string} decision.type - Decision type
 * @param {string} decision.sessionId - Session ID
 * @param {number} decision.iteration - Iteration number
 * @param {string} decision.title - Decision title
 * @param {string} decision.context - Decision context
 * @param {string} decision.chosen - Chosen option
 * @param {string} decision.reasoning - Decision reasoning
 * @param {Array} [decision.alternatives] - Alternatives considered
 * @param {Object} [decision.criteria] - Decision criteria
 * @param {Object} [decision.outcome] - Outcome (if known)
 * @param {Object} [options] - Generation options
 * @returns {Promise<{filepath: string, artifactId: string}>}
 */
export async function generateDecisionArtifact(decision, options = {}) {
  const artifactsRoot = options.artifactsRoot || '.forgekeeper/artifacts';
  const timestamp = new Date().toISOString();
  const date = timestamp.split('T')[0];
  const artifactId = ulid();

  // Generate markdown content
  const markdown = `# Decision: ${decision.title}

**Artifact ID**: \`${artifactId}\`
**Type**: ${decision.type}
**Session**: \`${decision.sessionId}\`
**Iteration**: ${decision.iteration}
**Timestamp**: ${timestamp}

---

## ðŸŽ¯ Context

${decision.context}

---

## âœ… Decision Made

**Chosen**: ${decision.chosen}

**Reasoning**: ${decision.reasoning}

---

## ðŸ”€ Alternatives Considered

${decision.alternatives && decision.alternatives.length > 0
    ? decision.alternatives.map((alt, idx) => `
### Alternative ${idx + 1}: ${alt.name}

${alt.description || '_No description provided._'}

**Pros**:
${alt.pros ? alt.pros.map(p => `- ${p}`).join('\n') : '- _None listed_'}

**Cons**:
${alt.cons ? alt.cons.map(c => `- ${c}`).join('\n') : '- _None listed_'}

${alt.score !== undefined ? `**Score**: ${alt.score.toFixed(2)}` : ''}
${alt.rank !== undefined ? `**Rank**: #${alt.rank}` : ''}
    `).join('\n---\n')
    : '_No alternatives were considered._'}

---

## ðŸ“ Decision Criteria

${decision.criteria ? formatCriteria(decision.criteria) : '_No explicit criteria recorded._'}

---

## ðŸ“Š Outcome

${decision.outcome ? `
**Status**: ${decision.outcome.success ? 'âœ… Success' : 'âŒ Failure'}
**Result**: ${decision.outcome.result}
${decision.outcome.actualVsPredicted ? `**Prediction Accuracy**: ${decision.outcome.actualVsPredicted}` : ''}
${decision.outcome.lessonsLearned ? `\n**Lessons Learned**:\n${decision.outcome.lessonsLearned.map(l => `- ${l}`).join('\n')}` : ''}
` : '_Outcome not yet known._'}

---

## ðŸ”— Related Artifacts

${decision.relatedArtifacts ? decision.relatedArtifacts.map(a => `- [${a.type}] \`${a.id}\``).join('\n') : '_No related artifacts._'}

---

*Generated by Forgekeeper Decision Tracking System on ${timestamp}*
`;

  // Create directory structure: artifacts/decisions/YYYY-MM-DD/
  const decisionDir = path.join(artifactsRoot, 'decisions', date);
  await fs.mkdir(decisionDir, { recursive: true });

  // Write artifact
  const filename = `decision-${decision.type}-${artifactId}.md`;
  const filepath = path.join(decisionDir, filename);
  await fs.writeFile(filepath, markdown, 'utf-8');

  // Write metadata
  const metadataPath = path.join(decisionDir, `decision-${decision.type}-${artifactId}.json`);
  await fs.writeFile(metadataPath, JSON.stringify({
    artifactId,
    type: decision.type,
    sessionId: decision.sessionId,
    iteration: decision.iteration,
    title: decision.title,
    chosen: decision.chosen,
    alternativesCount: decision.alternatives?.length || 0,
    hasOutcome: !!decision.outcome,
    outcomeSuccess: decision.outcome?.success,
    timestamp,
  }, null, 2), 'utf-8');

  console.log(`[DecisionArtifacts] Generated decision artifact: ${filepath}`);

  return { filepath, artifactId, metadataPath };
}

/**
 * Generate a decision journal (aggregated decisions for a session)
 *
 * @param {Object} journal - Journal data
 * @param {string} journal.sessionId - Session ID
 * @param {Array} journal.decisions - All decisions made
 * @param {Object} journal.summary - Summary stats
 * @param {Object} [options] - Generation options
 * @returns {Promise<{filepath: string, artifactId: string}>}
 */
export async function generateDecisionJournal(journal, options = {}) {
  const artifactsRoot = options.artifactsRoot || '.forgekeeper/artifacts';
  const timestamp = new Date().toISOString();
  const date = timestamp.split('T')[0];
  const artifactId = ulid();

  const markdown = `# Decision Journal: Session ${journal.sessionId}

**Artifact ID**: \`${artifactId}\`
**Session**: \`${journal.sessionId}\`
**Date**: ${timestamp}
**Total Decisions**: ${journal.decisions.length}

---

## ðŸ“Š Summary

| Metric | Value |
|--------|-------|
| Total Decisions | ${journal.decisions.length} |
| Alternative Selections | ${journal.decisions.filter(d => d.type === 'alternative_selection').length} |
| Approval Requests | ${journal.decisions.filter(d => d.type === 'approval').length} |
| Recovery Strategies | ${journal.decisions.filter(d => d.type === 'recovery_strategy').length} |
| Successful Outcomes | ${journal.decisions.filter(d => d.outcome?.success).length} |
| Failed Outcomes | ${journal.decisions.filter(d => d.outcome?.success === false).length} |

---

## ðŸ“– Decision Timeline

${journal.decisions.map((d, idx) => `
### Decision ${idx + 1}: ${d.title} (Iteration ${d.iteration})

**Type**: ${d.type}
**Chosen**: ${d.chosen}
**Reasoning**: ${d.reasoning}
${d.alternatives ? `**Alternatives**: ${d.alternatives.length}` : ''}
${d.outcome ? `**Outcome**: ${d.outcome.success ? 'âœ… Success' : 'âŒ Failure'}` : ''}

[View Full Decision](./decision-${d.type}-${d.artifactId}.md)
`).join('\n---\n')}

---

## ðŸ’¡ Insights

${generateJournalInsights(journal.decisions)}

---

*Generated by Forgekeeper Decision Journal System on ${timestamp}*
`;

  // Create directory
  const journalDir = path.join(artifactsRoot, 'decisions', date);
  await fs.mkdir(journalDir, { recursive: true });

  // Write journal
  const filename = `journal-${journal.sessionId}-${artifactId}.md`;
  const filepath = path.join(journalDir, filename);
  await fs.writeFile(filepath, markdown, 'utf-8');

  console.log(`[DecisionArtifacts] Generated decision journal: ${filepath}`);

  return { filepath, artifactId };
}

/**
 * Format decision criteria
 *
 * @param {Object} criteria - Criteria object
 * @returns {string} Formatted markdown
 */
function formatCriteria(criteria) {
  let output = '';

  if (criteria.weights) {
    output += '**Weights**:\n\n';
    output += '| Criterion | Weight |\n|-----------|--------|\n';
    Object.entries(criteria.weights).forEach(([key, value]) => {
      output += `| ${key} | ${(value * 100).toFixed(0)}% |\n`;
    });
    output += '\n';
  }

  if (criteria.thresholds) {
    output += '**Thresholds**:\n\n';
    output += '```json\n';
    output += JSON.stringify(criteria.thresholds, null, 2);
    output += '\n```\n\n';
  }

  if (criteria.priorities) {
    output += '**Priorities**:\n\n';
    criteria.priorities.forEach((p, idx) => {
      output += `${idx + 1}. ${p}\n`;
    });
    output += '\n';
  }

  return output;
}

/**
 * Generate insights from decision journal
 *
 * @param {Array} decisions - All decisions
 * @returns {string} Markdown insights
 */
function generateJournalInsights(decisions) {
  const insights = [];

  // Insight 1: Most common decision type
  const typeCounts = decisions.reduce((acc, d) => {
    acc[d.type] = (acc[d.type] || 0) + 1;
    return acc;
  }, {});

  const mostCommon = Object.entries(typeCounts).sort((a, b) => b[1] - a[1])[0];
  if (mostCommon) {
    insights.push(`- Most common decision type: **${mostCommon[0]}** (${mostCommon[1]} decisions)`);
  }

  // Insight 2: Success rate of decisions with outcomes
  const withOutcomes = decisions.filter(d => d.outcome);
  if (withOutcomes.length > 0) {
    const successful = withOutcomes.filter(d => d.outcome.success).length;
    const rate = (successful / withOutcomes.length * 100).toFixed(1);
    insights.push(`- Decision outcome success rate: **${rate}%** (${successful}/${withOutcomes.length})`);
  }

  // Insight 3: Average alternatives considered
  const withAlternatives = decisions.filter(d => d.alternatives && d.alternatives.length > 0);
  if (withAlternatives.length > 0) {
    const avgAlternatives = withAlternatives.reduce((sum, d) => sum + d.alternatives.length, 0) / withAlternatives.length;
    insights.push(`- Average alternatives considered: **${avgAlternatives.toFixed(1)}** per decision`);
  }

  // Insight 4: Decision distribution across iterations
  const earlyDecisions = decisions.filter(d => d.iteration <= 5).length;
  const lateDecisions = decisions.filter(d => d.iteration > 5).length;
  if (earlyDecisions + lateDecisions > 0) {
    insights.push(`- Decision timing: **${earlyDecisions}** in early iterations (1-5), **${lateDecisions}** in later iterations`);
  }

  return insights.length > 0 ? insights.join('\n') : '_No insights generated._';
}

/**
 * Search decision artifacts by criteria
 *
 * @param {Object} criteria - Search criteria
 * @param {string} [criteria.type] - Decision type filter
 * @param {string} [criteria.sessionId] - Session ID filter
 * @param {boolean} [criteria.hasOutcome] - Filter by outcome presence
 * @param {boolean} [criteria.outcomeSuccess] - Filter by outcome success
 * @param {Object} [options] - Search options
 * @returns {Promise<Array<Object>>} Matching decision artifacts
 */
export async function searchDecisionArtifacts(criteria, options = {}) {
  const artifactsRoot = options.artifactsRoot || '.forgekeeper/artifacts';
  const decisionsDir = path.join(artifactsRoot, 'decisions');

  try {
    const dates = await fs.readdir(decisionsDir);
    const results = [];

    for (const date of dates) {
      const dateDir = path.join(decisionsDir, date);
      const files = await fs.readdir(dateDir);
      const jsonFiles = files.filter(f => f.endsWith('.json') && !f.includes('journal'));

      for (const file of jsonFiles) {
        const filePath = path.join(dateDir, file);
        const content = await fs.readFile(filePath, 'utf-8');
        const metadata = JSON.parse(content);

        // Apply filters
        if (criteria.type && metadata.type !== criteria.type) continue;
        if (criteria.sessionId && metadata.sessionId !== criteria.sessionId) continue;
        if (criteria.hasOutcome !== undefined && (!!metadata.hasOutcome) !== criteria.hasOutcome) continue;
        if (criteria.outcomeSuccess !== undefined && metadata.outcomeSuccess !== criteria.outcomeSuccess) continue;

        results.push({
          ...metadata,
          markdownPath: filePath.replace('.json', '.md'),
        });
      }
    }

    // Sort by timestamp descending
    results.sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));

    return results;
  } catch (err) {
    console.error('[DecisionArtifacts] Search failed:', err.message);
    return [];
  }
}
