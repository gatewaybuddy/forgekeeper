/**
 * Session Artifact Generator
 *
 * Generates persistent markdown artifacts from autonomous agent sessions.
 * Stores knowledge as documents instead of ephemeral cache.
 *
 * Artifact Types:
 * - Session summaries: Complete session reports with actions, results, learnings
 * - Quick references: Key decisions and outcomes for fast lookup
 * - Timeline: Chronological action history
 *
 * @module server/automation/session-artifacts
 */

import fs from 'fs/promises';
import path from 'path';
import { ulid } from 'ulid';

/**
 * Generate a session artifact from autonomous agent session data
 *
 * @param {Object} session - Session data
 * @param {string} session.sessionId - Unique session ID
 * @param {string} session.task - Original task description
 * @param {string} session.reason - Completion reason
 * @param {number} session.iterations - Number of iterations
 * @param {number} session.confidence - Final confidence (0-1)
 * @param {Array} session.history - Iteration history
 * @param {Object} session.state - Final state
 * @param {string} [session.summary] - Human-readable summary
 * @param {Object} [options] - Generation options
 * @param {string} [options.artifactsRoot] - Artifacts directory root
 * @returns {Promise<{filepath: string, artifactId: string}>}
 */
export async function generateSessionArtifact(session, options = {}) {
  const artifactsRoot = options.artifactsRoot || '.forgekeeper/artifacts';
  const timestamp = new Date().toISOString();
  const date = timestamp.split('T')[0]; // YYYY-MM-DD
  const artifactId = ulid();

  // Extract key metrics
  const totalTools = session.history.flatMap(h => h.tools_used || []).length;
  const uniqueTools = [...new Set(session.history.flatMap(h => h.tools_used || []))];
  const errorCount = session.history.filter(h => h.error).length;
  const successRate = ((session.iterations - errorCount) / session.iterations * 100).toFixed(1);

  // Extract learnings from session
  const learnings = extractLearnings(session);

  // Extract key decisions
  const decisions = extractDecisions(session);

  // Generate markdown content
  const markdown = `# Session Summary: ${session.task}

**Session ID**: \`${session.sessionId}\`
**Artifact ID**: \`${artifactId}\`
**Date**: ${timestamp}
**Duration**: ${session.iterations} iterations
**Outcome**: ${session.reason}
**Confidence**: ${(session.confidence * 100).toFixed(1)}%

---

## üìä Metrics

| Metric | Value |
|--------|-------|
| Total Actions | ${totalTools} |
| Unique Tools | ${uniqueTools.length} |
| Success Rate | ${successRate}% |
| Errors | ${errorCount} |
| Final Progress | ${session.state?.lastProgressPercent || 0}% |

---

## üéØ Task

${session.task}

---

## üìù Summary

${session.summary || 'No summary provided.'}

---

## üîß Tools Used

${uniqueTools.map(tool => `- \`${tool}\``).join('\n')}

---

## üìö Learnings

${learnings.length > 0 ? learnings.map(l => `### ${l.title}\n\n${l.description}\n\n**Evidence**: ${l.evidence}\n`).join('\n') : '_No learnings captured._'}

---

## ü§î Key Decisions

${decisions.length > 0 ? decisions.map(d => `### Iteration ${d.iteration}: ${d.title}\n\n**Decision**: ${d.decision}\n**Reasoning**: ${d.reasoning}\n${d.alternatives ? `**Alternatives Considered**: ${d.alternatives}\n` : ''}`).join('\n') : '_No key decisions recorded._'}

---

## üìñ Action Timeline

${generateTimeline(session.history)}

---

## üîç Detailed History

<details>
<summary>Click to expand full iteration history</summary>

${generateDetailedHistory(session.history)}

</details>

---

## üì¶ Session State

\`\`\`json
${JSON.stringify({
  taskComplete: session.state?.taskComplete,
  confidence: session.confidence,
  iterations: session.iterations,
  errors: errorCount,
  reason: session.reason,
}, null, 2)}
\`\`\`

---

*Generated by Forgekeeper Artifact System on ${timestamp}*
`;

  // Create directory structure: artifacts/sessions/YYYY-MM-DD/
  const sessionDir = path.join(artifactsRoot, 'sessions', date);
  await fs.mkdir(sessionDir, { recursive: true });

  // Write artifact
  const filename = `session-${session.sessionId}-${artifactId}.md`;
  const filepath = path.join(sessionDir, filename);
  await fs.writeFile(filepath, markdown, 'utf-8');

  // Also write a quick-reference JSON for fast lookup
  const metadataPath = path.join(sessionDir, `session-${session.sessionId}-${artifactId}.json`);
  await fs.writeFile(metadataPath, JSON.stringify({
    artifactId,
    sessionId: session.sessionId,
    timestamp,
    task: session.task,
    outcome: session.reason,
    confidence: session.confidence,
    iterations: session.iterations,
    toolsUsed: uniqueTools,
    learnings: learnings.map(l => l.title),
    decisions: decisions.map(d => d.title),
    successRate: parseFloat(successRate),
  }, null, 2), 'utf-8');

  console.log(`[SessionArtifacts] Generated artifact: ${filepath}`);

  return { filepath, artifactId, metadataPath };
}

/**
 * Extract learnings from session history
 *
 * @param {Object} session - Session data
 * @returns {Array<{title: string, description: string, evidence: string}>}
 */
function extractLearnings(session) {
  const learnings = [];

  // Learning 1: Tool effectiveness
  const toolUsage = {};
  session.history.forEach(h => {
    (h.tools_used || []).forEach(tool => {
      if (!toolUsage[tool]) toolUsage[tool] = { success: 0, failure: 0 };
      if (h.error) toolUsage[tool].failure++;
      else toolUsage[tool].success++;
    });
  });

  const mostEffective = Object.entries(toolUsage)
    .map(([tool, stats]) => ({
      tool,
      rate: stats.success / (stats.success + stats.failure),
      total: stats.success + stats.failure,
    }))
    .sort((a, b) => b.rate - a.rate)[0];

  if (mostEffective && mostEffective.total > 1) {
    learnings.push({
      title: `Most Effective Tool: ${mostEffective.tool}`,
      description: `${mostEffective.tool} had the highest success rate for this task type.`,
      evidence: `${(mostEffective.rate * 100).toFixed(1)}% success rate across ${mostEffective.total} uses`,
    });
  }

  // Learning 2: Error patterns
  const errorPatterns = session.history
    .filter(h => h.error)
    .map(h => h.error.message)
    .reduce((acc, msg) => {
      acc[msg] = (acc[msg] || 0) + 1;
      return acc;
    }, {});

  const commonError = Object.entries(errorPatterns)
    .sort((a, b) => b[1] - a[1])[0];

  if (commonError && commonError[1] > 1) {
    learnings.push({
      title: `Common Error Pattern`,
      description: `Encountered recurring error: "${commonError[0]}"`,
      evidence: `Occurred ${commonError[1]} times during session`,
    });
  }

  // Learning 3: Recovery strategies
  if (session.state?.recoveryAttempts && session.state.recoveryAttempts.length > 0) {
    const successfulRecoveries = session.state.recoveryAttempts.filter(r => r.success);
    if (successfulRecoveries.length > 0) {
      learnings.push({
        title: `Successful Recovery Strategy`,
        description: `Recovery strategies worked in ${successfulRecoveries.length} out of ${session.state.recoveryAttempts.length} attempts.`,
        evidence: `Recovery success rate: ${(successfulRecoveries.length / session.state.recoveryAttempts.length * 100).toFixed(1)}%`,
      });
    }
  }

  return learnings;
}

/**
 * Extract key decisions from session history
 *
 * @param {Object} session - Session data
 * @returns {Array<{iteration: number, title: string, decision: string, reasoning: string, alternatives?: string}>}
 */
function extractDecisions(session) {
  const decisions = [];

  session.history.forEach((iteration, idx) => {
    // Decision: Chosen alternative from proactive planning
    if (iteration.chosen_alternative) {
      decisions.push({
        iteration: idx + 1,
        title: `Selected Alternative: ${iteration.chosen_alternative.alternativeName}`,
        decision: iteration.chosen_alternative.alternativeName,
        reasoning: iteration.chosen_alternative.justification || 'No justification provided',
        alternatives: iteration.alternatives_considered
          ? iteration.alternatives_considered.map(a => a.name).join(', ')
          : undefined,
      });
    }

    // Decision: Risk-based approval
    if (iteration.approval_requested) {
      decisions.push({
        iteration: idx + 1,
        title: `Approval Decision: ${iteration.approval_decision}`,
        decision: iteration.approval_decision,
        reasoning: `Risk level: ${iteration.risk_level}. ${iteration.approval_reasoning || ''}`,
      });
    }

    // Decision: Recovery strategy selection
    if (iteration.recovery_strategy) {
      decisions.push({
        iteration: idx + 1,
        title: `Recovery Strategy: ${iteration.recovery_strategy.name}`,
        decision: iteration.recovery_strategy.name,
        reasoning: iteration.recovery_strategy.reasoning || 'Automated recovery selection',
      });
    }
  });

  return decisions;
}

/**
 * Generate timeline of actions
 *
 * @param {Array} history - Session history
 * @returns {string} Markdown timeline
 */
function generateTimeline(history) {
  return history.map((h, idx) => {
    const tools = (h.tools_used || []).join(', ') || 'none';
    const status = h.error ? '‚ùå' : '‚úÖ';
    return `${idx + 1}. ${status} **Iteration ${idx + 1}**: ${tools}`;
  }).join('\n');
}

/**
 * Generate detailed history
 *
 * @param {Array} history - Session history
 * @returns {string} Markdown detailed history
 */
function generateDetailedHistory(history) {
  return history.map((h, idx) => {
    const tools = (h.tools_used || []).join(', ') || 'none';
    const status = h.error ? '‚ùå ERROR' : '‚úÖ SUCCESS';

    let details = `### Iteration ${idx + 1} - ${status}\n\n`;
    details += `**Tools**: ${tools}\n\n`;

    if (h.action) details += `**Action**: ${h.action}\n\n`;
    if (h.result) details += `**Result**: ${h.result.slice(0, 500)}${h.result.length > 500 ? '...' : ''}\n\n`;
    if (h.error) details += `**Error**: ${h.error.message}\n\n`;

    return details;
  }).join('\n---\n\n');
}
