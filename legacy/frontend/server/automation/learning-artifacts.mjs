/**
 * Learning Artifact Generator
 *
 * Generates persistent learning artifacts that accumulate knowledge over time.
 * Stores patterns, insights, and best practices as searchable documents.
 *
 * Artifact Types:
 * - Tool effectiveness patterns
 * - Error recovery strategies
 * - Task-specific best practices
 * - Performance optimizations
 *
 * @module server/automation/learning-artifacts
 */

import fs from 'fs/promises';
import path from 'path';
import { ulid } from 'ulid';

/**
 * Generate a learning artifact from session patterns
 *
 * @param {Object} learning - Learning data
 * @param {string} learning.category - Category (tool_effectiveness, error_recovery, best_practice, optimization)
 * @param {string} learning.title - Learning title
 * @param {string} learning.description - Detailed description
 * @param {string} learning.taskType - Task type this applies to
 * @param {Object} learning.evidence - Supporting evidence
 * @param {number} learning.confidence - Confidence level (0-1)
 * @param {Array<string>} [learning.tags] - Searchable tags
 * @param {Object} [options] - Generation options
 * @param {string} [options.artifactsRoot] - Artifacts directory root
 * @returns {Promise<{filepath: string, artifactId: string}>}
 */
export async function generateLearningArtifact(learning, options = {}) {
  const artifactsRoot = options.artifactsRoot || '.forgekeeper/artifacts';
  const timestamp = new Date().toISOString();
  const date = timestamp.split('T')[0];
  const artifactId = ulid();

  // Generate markdown content
  const markdown = `# Learning: ${learning.title}

**Artifact ID**: \`${artifactId}\`
**Category**: ${learning.category}
**Task Type**: ${learning.taskType}
**Confidence**: ${(learning.confidence * 100).toFixed(1)}%
**Date**: ${timestamp}
${learning.tags ? `**Tags**: ${learning.tags.map(t => `\`${t}\``).join(', ')}` : ''}

---

## üìù Description

${learning.description}

---

## üìä Evidence

${formatEvidence(learning.evidence)}

---

## üí° Recommendations

${learning.recommendations ? learning.recommendations.map(r => `- ${r}`).join('\n') : '_No specific recommendations._'}

---

## üîó Related Sessions

${learning.relatedSessions ? learning.relatedSessions.map(s => `- Session \`${s}\``).join('\n') : '_No related sessions linked._'}

---

## üìà Application History

${learning.applications ? formatApplications(learning.applications) : '_Not yet applied._'}

---

*Generated by Forgekeeper Learning System on ${timestamp}*
`;

  // Create directory structure
  const learningDir = path.join(artifactsRoot, 'learnings', learning.category);
  await fs.mkdir(learningDir, { recursive: true });

  // Write artifact
  const filename = `learning-${artifactId}.md`;
  const filepath = path.join(learningDir, filename);
  await fs.writeFile(filepath, markdown, 'utf-8');

  // Write metadata for indexing
  const metadataPath = path.join(learningDir, `learning-${artifactId}.json`);
  await fs.writeFile(metadataPath, JSON.stringify({
    artifactId,
    category: learning.category,
    title: learning.title,
    taskType: learning.taskType,
    confidence: learning.confidence,
    tags: learning.tags || [],
    timestamp,
    relatedSessions: learning.relatedSessions || [],
  }, null, 2), 'utf-8');

  console.log(`[LearningArtifacts] Generated learning artifact: ${filepath}`);

  return { filepath, artifactId, metadataPath };
}

/**
 * Generate a pattern artifact (accumulated learnings)
 *
 * @param {Object} pattern - Pattern data
 * @param {string} pattern.patternType - Type of pattern
 * @param {string} pattern.name - Pattern name
 * @param {string} pattern.description - Description
 * @param {Array} pattern.occurrences - Times this pattern was observed
 * @param {number} pattern.successRate - Success rate (0-1)
 * @param {Object} [options] - Generation options
 * @returns {Promise<{filepath: string, artifactId: string}>}
 */
export async function generatePatternArtifact(pattern, options = {}) {
  const artifactsRoot = options.artifactsRoot || '.forgekeeper/artifacts';
  const timestamp = new Date().toISOString();
  const artifactId = ulid();

  const markdown = `# Pattern: ${pattern.name}

**Artifact ID**: \`${artifactId}\`
**Pattern Type**: ${pattern.patternType}
**Observed**: ${pattern.occurrences.length} times
**Success Rate**: ${(pattern.successRate * 100).toFixed(1)}%
**Last Updated**: ${timestamp}

---

## üìù Description

${pattern.description}

---

## üìä Statistics

| Metric | Value |
|--------|-------|
| Total Occurrences | ${pattern.occurrences.length} |
| Successful | ${pattern.occurrences.filter(o => o.success).length} |
| Failed | ${pattern.occurrences.filter(o => !o.success).length} |
| Success Rate | ${(pattern.successRate * 100).toFixed(1)}% |
| First Seen | ${pattern.occurrences[0]?.timestamp || 'Unknown'} |
| Last Seen | ${pattern.occurrences[pattern.occurrences.length - 1]?.timestamp || 'Unknown'} |

---

## üîç Occurrence Details

${pattern.occurrences.map((occ, idx) => `
### Occurrence ${idx + 1} - ${occ.success ? '‚úÖ Success' : '‚ùå Failure'}

**Session**: \`${occ.sessionId}\`
**Timestamp**: ${occ.timestamp}
${occ.context ? `**Context**: ${occ.context}` : ''}
${occ.outcome ? `**Outcome**: ${occ.outcome}` : ''}
`).join('\n---\n')}

---

## üí° Insights

${pattern.insights ? pattern.insights.map(i => `- ${i}`).join('\n') : '_No insights extracted yet._'}

---

*Generated by Forgekeeper Pattern Recognition System on ${timestamp}*
`;

  // Create directory structure
  const patternDir = path.join(artifactsRoot, 'patterns', pattern.patternType);
  await fs.mkdir(patternDir, { recursive: true });

  // Write artifact
  const filename = `pattern-${pattern.name.toLowerCase().replace(/\s+/g, '-')}-${artifactId}.md`;
  const filepath = path.join(patternDir, filename);
  await fs.writeFile(filepath, markdown, 'utf-8');

  // Write metadata
  const metadataPath = path.join(patternDir, `pattern-${artifactId}.json`);
  await fs.writeFile(metadataPath, JSON.stringify({
    artifactId,
    patternType: pattern.patternType,
    name: pattern.name,
    occurrences: pattern.occurrences.length,
    successRate: pattern.successRate,
    timestamp,
  }, null, 2), 'utf-8');

  console.log(`[LearningArtifacts] Generated pattern artifact: ${filepath}`);

  return { filepath, artifactId, metadataPath };
}

/**
 * Format evidence object as markdown
 *
 * @param {Object} evidence - Evidence data
 * @returns {string} Formatted markdown
 */
function formatEvidence(evidence) {
  if (!evidence) return '_No evidence provided._';

  let output = '';

  if (evidence.sessions) {
    output += `**Sessions Analyzed**: ${evidence.sessions}\n\n`;
  }

  if (evidence.successRate !== undefined) {
    output += `**Success Rate**: ${(evidence.successRate * 100).toFixed(1)}%\n\n`;
  }

  if (evidence.dataPoints) {
    output += `**Data Points**: ${evidence.dataPoints}\n\n`;
  }

  if (evidence.metrics) {
    output += '**Metrics**:\n\n';
    output += '```json\n';
    output += JSON.stringify(evidence.metrics, null, 2);
    output += '\n```\n\n';
  }

  if (evidence.examples) {
    output += '**Examples**:\n\n';
    evidence.examples.forEach((ex, idx) => {
      output += `${idx + 1}. ${ex}\n`;
    });
    output += '\n';
  }

  return output;
}

/**
 * Format application history
 *
 * @param {Array} applications - Application records
 * @returns {string} Formatted markdown
 */
function formatApplications(applications) {
  return applications.map((app, idx) => `
### Application ${idx + 1} - ${app.success ? '‚úÖ Success' : '‚ùå Failure'}

**Session**: \`${app.sessionId}\`
**Date**: ${app.timestamp}
**Outcome**: ${app.outcome}
${app.notes ? `**Notes**: ${app.notes}` : ''}
  `).join('\n---\n');
}

/**
 * Search learning artifacts by criteria
 *
 * @param {Object} criteria - Search criteria
 * @param {string} [criteria.category] - Category filter
 * @param {string} [criteria.taskType] - Task type filter
 * @param {Array<string>} [criteria.tags] - Tag filter
 * @param {number} [criteria.minConfidence] - Minimum confidence
 * @param {Object} [options] - Search options
 * @returns {Promise<Array<Object>>} Matching learning artifacts
 */
export async function searchLearningArtifacts(criteria, options = {}) {
  const artifactsRoot = options.artifactsRoot || '.forgekeeper/artifacts';
  const learningDir = path.join(artifactsRoot, 'learnings');

  try {
    const categories = criteria.category
      ? [criteria.category]
      : await fs.readdir(learningDir);

    const results = [];

    for (const category of categories) {
      const categoryDir = path.join(learningDir, category);
      try {
        const files = await fs.readdir(categoryDir);
        const jsonFiles = files.filter(f => f.endsWith('.json'));

        for (const file of jsonFiles) {
          const filePath = path.join(categoryDir, file);
          const content = await fs.readFile(filePath, 'utf-8');
          const metadata = JSON.parse(content);

          // Apply filters
          if (criteria.taskType && metadata.taskType !== criteria.taskType) continue;
          if (criteria.minConfidence && metadata.confidence < criteria.minConfidence) continue;
          if (criteria.tags && !criteria.tags.some(tag => metadata.tags.includes(tag))) continue;

          results.push({
            ...metadata,
            markdownPath: filePath.replace('.json', '.md'),
          });
        }
      } catch (err) {
        // Category directory might not exist
        continue;
      }
    }

    // Sort by confidence descending
    results.sort((a, b) => b.confidence - a.confidence);

    return results;
  } catch (err) {
    console.error('[LearningArtifacts] Search failed:', err.message);
    return [];
  }
}
