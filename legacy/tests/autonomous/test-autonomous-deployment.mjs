#!/usr/bin/env node

/**
 * AUTONOMOUS DEPLOYMENT TEST
 *
 * This test validates the agent's ability to:
 * 1. Make a change to its own code
 * 2. Commit the change to git
 * 3. Push to GitHub
 * 4. Restart itself to apply the change
 *
 * This is the ultimate test of autonomous self-evolution!
 */

// Use global fetch available in Node >=18
import fs from 'fs/promises';
import path from 'path';

const API_BASE = process.env.API_BASE || 'http://localhost:3000';
const RESULTS_DIR = '.forgekeeper/deployment-test-results';

// Colors
const colors = {
  reset: '\x1b[0m',
  bright: '\x1b[1m',
  red: '\x1b[31m',
  green: '\x1b[32m',
  yellow: '\x1b[33m',
  blue: '\x1b[34m',
  cyan: '\x1b[36m',
};

function log(message, color = 'reset') {
  console.log(`${colors[color]}${message}${colors.reset}`);
}

function section(title) {
  console.log('\n' + '='.repeat(80));
  log(title, 'bright');
  console.log('='.repeat(80) + '\n');
}

// Ensure results directory
await fs.mkdir(RESULTS_DIR, { recursive: true });

section('üöÄ AUTONOMOUS DEPLOYMENT TEST');
log('Testing agent ability to deploy changes to itself autonomously', 'cyan');

// ============================================================================
// PHASE 1: VERIFY TOOLS AVAILABLE
// ============================================================================
section('üîß PHASE 1: VERIFY DEPLOYMENT TOOLS');

let availableTools = [];
try {
  const resp = await fetch(`${API_BASE}/api/tools`);
  const data = await resp.json();
  availableTools = data.names || [];

  const requiredTools = ['git_add', 'git_commit', 'git_push', 'restart_frontend', 'write_file', 'read_file'];
  const missingTools = requiredTools.filter(t => !availableTools.includes(t));

  if (missingTools.length > 0) {
    log(`‚úó Missing required tools: ${missingTools.join(', ')}`, 'red');
    log('The agent needs git and restart tools for autonomous deployment', 'yellow');
    process.exit(1);
  }

  log(`‚úì All deployment tools available`, 'green');
  log(`  ‚Ä¢ git_add: Stage changes`, 'yellow');
  log(`  ‚Ä¢ git_commit: Commit changes`, 'yellow');
  log(`  ‚Ä¢ git_push: Push to GitHub`, 'yellow');
  log(`  ‚Ä¢ restart_frontend: Restart itself`, 'yellow');

  await fs.writeFile(
    path.join(RESULTS_DIR, 'phase1-tools.json'),
    JSON.stringify({ available: true, tools: requiredTools }, null, 2)
  );

} catch (error) {
  log(`‚úó Failed to verify tools: ${error.message}`, 'red');
  log('Make sure the server is running: npm run dev', 'yellow');
  process.exit(1);
}

// ============================================================================
// PHASE 2: AUTONOMOUS DEPLOYMENT TASK
// ============================================================================
section('ü§ñ PHASE 2: AUTONOMOUS DEPLOYMENT');

const deploymentTask = `You are an autonomous agent capable of deploying changes to yourself!

**Mission**: Make a small, safe change to your own code, commit it, push to GitHub, and restart yourself.

**Task Breakdown**:

1. **Create a test marker file**
   - Create a file: "frontend/AUTONOMOUS_DEPLOYMENT_TEST_MARKER.txt"
   - Content: "Deployed autonomously at [timestamp]\\n\\nThis file proves the agent can:\\n1. Modify its own codebase\\n2. Commit changes to git\\n3. Push to GitHub\\n4. Restart itself\\n\\nGenerated by autonomous agent self-deployment test."
   - Use write_file tool

2. **Stage the change**
   - Use git_add tool
   - Stage: "frontend/AUTONOMOUS_DEPLOYMENT_TEST_MARKER.txt"

3. **Commit the change**
   - Use git_commit tool
   - Message: "feat(autonomous): autonomous self-deployment test marker\\n\\nThis commit was created autonomously by the agent to demonstrate:\\n- Self-modification capability\\n- Git workflow automation\\n- Autonomous deployment\\n\\nTest run: [timestamp]"

4. **Push to GitHub**
   - Use git_push tool
   - Remote: origin
   - Branch: main (or current branch)

5. **Verify push succeeded**
   - Check the git_push output
   - Confirm no errors

6. **Restart frontend** (OPTIONAL - only if you're confident)
   - Use restart_frontend tool
   - This will restart the server to apply changes
   - Note: Only do this if all previous steps succeeded!

**Success Criteria**:
‚úÖ File created with timestamp
‚úÖ Changes staged with git_add
‚úÖ Commit created with proper message
‚úÖ Commit pushed to GitHub (check output for "main -> main" or similar)
‚úÖ (Optional) Frontend restarted

**Important Safety Notes**:
- This is a REAL deployment to REAL GitHub
- The marker file is harmless (just text)
- DO NOT modify critical code files
- DO NOT restart if push failed
- Be METHODICAL and CAREFUL

**Tools Required**:
- write_file (create marker)
- git_add (stage)
- git_commit (commit)
- git_push (push)
- git_status (verify)
- restart_frontend (optional restart)

Begin autonomous deployment now!`;

let deploymentSession;
let sessionId;

try {
  log('Starting autonomous deployment session...', 'cyan');
  log('Agent will: create marker ‚Üí stage ‚Üí commit ‚Üí push ‚Üí (optionally) restart', 'yellow');

  const response = await fetch(`${API_BASE}/api/chat/autonomous`, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({
      task: deploymentTask,
      max_iterations: 25, // Give plenty of room
      async: true
    })
  });

  const data = await response.json();

  if (!data.ok) {
    throw new Error(data.error || 'Failed to start deployment session');
  }

  sessionId = data.session_id;
  log(`‚úì Deployment session started: ${sessionId}`, 'green');

  // Poll for completion
  log('Waiting for agent to complete deployment...', 'cyan');
  let attempts = 0;
  const maxAttempts = 180; // 3 minutes max (git push can be slow)

  while (attempts < maxAttempts) {
    await new Promise(resolve => setTimeout(resolve, 1000));
    attempts++;

    const statusResp = await fetch(`${API_BASE}/api/chat/autonomous/status?session_id=${sessionId}`);
    const statusData = await statusResp.json();

    if (statusData.done) {
      deploymentSession = statusData.result;
      log(`‚úì Deployment complete after ${attempts} seconds`, 'green');
      break;
    }

    // Progress updates
    if (attempts % 10 === 0) {
      log(`  Still deploying... (${attempts}s elapsed)`, 'yellow');
    }
  }

  if (!deploymentSession) {
    throw new Error('Deployment timed out after 3 minutes');
  }

  // Get detailed events
  const eventsResp = await fetch(`${API_BASE}/api/ctx/tail.json?n=2000&session_id=${sessionId}`);
  const events = await eventsResp.json();

  // Analyze deployment
  const iterations = events.filter(e => e.type === 'autonomous_iteration').length;
  const toolCalls = events.filter(e => e.type === 'tool_call_end_autonomous');
  const toolsUsed = [...new Set(toolCalls.map(e => e.name))];
  const errors = events.filter(e => e.status === 'error' || e.type === 'error').length;

  console.log('\nüìä Deployment Statistics:');
  log(`  Iterations: ${iterations}`, 'yellow');
  log(`  Tools used: ${toolsUsed.join(', ')}`, 'yellow');
  log(`  Errors: ${errors}`, errors > 0 ? 'red' : 'green');
  log(`  Reason: ${deploymentSession.reason || 'unknown'}`, 'yellow');

  // Check which tools were used
  const usedWriteFile = toolsUsed.includes('write_file');
  const usedGitAdd = toolsUsed.includes('git_add');
  const usedGitCommit = toolsUsed.includes('git_commit');
  const usedGitPush = toolsUsed.includes('git_push');
  const usedRestart = toolsUsed.includes('restart_frontend');

  console.log('\n‚úÖ Deployment Steps Completed:');
  log(`  ${usedWriteFile ? '‚úì' : '‚úó'} Created marker file`, usedWriteFile ? 'green' : 'red');
  log(`  ${usedGitAdd ? '‚úì' : '‚úó'} Staged changes (git add)`, usedGitAdd ? 'green' : 'red');
  log(`  ${usedGitCommit ? '‚úì' : '‚úó'} Committed changes (git commit)`, usedGitCommit ? 'green' : 'red');
  log(`  ${usedGitPush ? '‚úì' : '‚úó'} Pushed to GitHub (git push)`, usedGitPush ? 'green' : 'red');
  log(`  ${usedRestart ? '‚úì' : '‚äò'} Restarted frontend (optional)`, usedRestart ? 'green' : 'yellow');

  // Detailed tool analysis
  console.log('\nüìã Tool Execution Details:');
  for (const toolCall of toolCalls) {
    const status = toolCall.status === 'ok' ? '‚úì' : '‚úó';
    const color = toolCall.status === 'ok' ? 'green' : 'red';
    log(`  ${status} ${toolCall.name}: ${toolCall.result_preview?.substring(0, 60) || 'completed'}`, color);
  }

  // Save results
  await fs.writeFile(
    path.join(RESULTS_DIR, 'phase2-deployment.json'),
    JSON.stringify({
      session: deploymentSession,
      sessionId,
      events,
      statistics: {
        iterations,
        tools_used: toolsUsed,
        errors,
        write_file: usedWriteFile,
        git_add: usedGitAdd,
        git_commit: usedGitCommit,
        git_push: usedGitPush,
        restart_frontend: usedRestart,
      }
    }, null, 2)
  );

  // Success check
  const allGitStepsComplete = usedGitAdd && usedGitCommit && usedGitPush;
  const deploymentSuccessful = usedWriteFile && allGitStepsComplete && errors === 0;

  if (deploymentSuccessful) {
    log('\nüéâ DEPLOYMENT SUCCESSFUL!', 'green');
    log('   Agent autonomously:', 'green');
    log('   1. Created marker file', 'green');
    log('   2. Staged changes with git', 'green');
    log('   3. Committed to repository', 'green');
    log('   4. Pushed to GitHub', 'green');
    if (usedRestart) {
      log('   5. Restarted itself!', 'green');
    }
  } else {
    log('\n‚ö†Ô∏è  DEPLOYMENT INCOMPLETE', 'yellow');
    if (!usedWriteFile) log('   Missing: File creation', 'yellow');
    if (!usedGitAdd) log('   Missing: git add', 'yellow');
    if (!usedGitCommit) log('   Missing: git commit', 'yellow');
    if (!usedGitPush) log('   Missing: git push', 'yellow');
    if (errors > 0) log(`   Errors encountered: ${errors}`, 'red');
  }

} catch (error) {
  log(`‚úó Deployment failed: ${error.message}`, 'red');
  deploymentSession = { error: error.message };

  await fs.writeFile(
    path.join(RESULTS_DIR, 'phase2-deployment.json'),
    JSON.stringify({ error: error.message }, null, 2)
  );
}

// ============================================================================
// PHASE 3: VERIFY DEPLOYMENT
// ============================================================================
section('üîç PHASE 3: VERIFY DEPLOYMENT');

let verificationPassed = false;

try {
  log('Checking if marker file exists...', 'cyan');

  // Check if marker file was created
  const markerPath = '/mnt/d/projects/codex/forgekeeper/frontend/AUTONOMOUS_DEPLOYMENT_TEST_MARKER.txt';
  try {
    const markerContent = await fs.readFile(markerPath, 'utf8');
    log(`‚úì Marker file exists!`, 'green');
    log(`  Content preview: ${markerContent.substring(0, 100)}...`, 'yellow');
    verificationPassed = true;
  } catch {
    log(`‚úó Marker file not found at: ${markerPath}`, 'red');
    log(`  Agent may not have created the file`, 'yellow');
  }

  // Check git status
  log('\nChecking git status...', 'cyan');
  const { execFile } = await import('child_process');
  const { promisify } = await import('util');
  const execFileAsync = promisify(execFile);

  try {
    const { stdout } = await execFileAsync('git', ['log', '-1', '--oneline'], {
      cwd: '/mnt/d/projects/codex/forgekeeper'
    });
    log(`‚úì Latest commit: ${stdout.trim()}`, 'green');

    // Check if it's the autonomous deployment commit
    if (stdout.includes('autonomous') || stdout.includes('self-deployment')) {
      log(`  ‚úì This appears to be the autonomous deployment commit!`, 'green');
    }
  } catch (err) {
    log(`‚ö†Ô∏è  Could not check git log: ${err.message}`, 'yellow');
  }

} catch (error) {
  log(`‚ö†Ô∏è  Verification encountered error: ${error.message}`, 'yellow');
}

// ============================================================================
// FINAL REPORT
// ============================================================================
section('üìã FINAL REPORT');

const report = {
  timestamp: new Date().toISOString(),
  test_name: 'Autonomous Deployment Test',
  phases: {
    tools_verification: {
      status: availableTools.length > 0 ? 'success' : 'failed',
      required_tools: ['git_add', 'git_commit', 'git_push', 'restart_frontend'],
    },
    deployment: {
      status: deploymentSession?.error ? 'failed' : 'completed',
      session_id: sessionId || 'unknown',
      reason: deploymentSession?.reason || deploymentSession?.error || 'unknown',
      tools_used: deploymentSession?.error ? [] : (
        await (async () => {
          const eventsResp = await fetch(`${API_BASE}/api/ctx/tail.json?n=2000&session_id=${sessionId}`);
          const events = await eventsResp.json();
          const toolCalls = events.filter(e => e.type === 'tool_call_end_autonomous');
          return [...new Set(toolCalls.map(e => e.name))];
        })().catch(() => [])
      ),
    },
    verification: {
      status: verificationPassed ? 'success' : 'failed',
      marker_file_exists: verificationPassed,
    },
  },
  capabilities_demonstrated: {
    self_modification: verificationPassed,
    git_workflow: deploymentSession?.error ? false : true,
    autonomous_push: deploymentSession?.error ? false : true,
    self_restart: false, // Will be true if restart was used
  },
  overall_success: !!(
    availableTools.length > 0 &&
    deploymentSession &&
    !deploymentSession.error &&
    verificationPassed
  ),
};

// Print summary
log('üéØ AUTONOMOUS DEPLOYMENT SUMMARY', 'bright');
console.log('‚îÄ'.repeat(80));

log(`\n1Ô∏è‚É£  Tools Verification: ${report.phases.tools_verification.status.toUpperCase()}`,
    report.phases.tools_verification.status === 'success' ? 'green' : 'red');

log(`\n2Ô∏è‚É£  Deployment: ${report.phases.deployment.status.toUpperCase()}`,
    report.phases.deployment.status === 'completed' ? 'green' : 'red');
log(`   ‚Ä¢ Session: ${report.phases.deployment.session_id}`, 'yellow');
log(`   ‚Ä¢ Result: ${report.phases.deployment.reason}`, 'yellow');

log(`\n3Ô∏è‚É£  Verification: ${report.phases.verification.status.toUpperCase()}`,
    report.phases.verification.status === 'success' ? 'green' : 'red');
log(`   ‚Ä¢ Marker file: ${report.phases.verification.marker_file_exists ? 'Created ‚úì' : 'Missing ‚úó'}`,
    report.phases.verification.marker_file_exists ? 'green' : 'red');

console.log('\n' + '‚îÄ'.repeat(80));
log(`\nüèÜ OVERALL: ${report.overall_success ? 'SUCCESS ‚úì' : 'INCOMPLETE ‚úó'}`,
    report.overall_success ? 'green' : 'yellow');

if (report.overall_success) {
  log('\nüéâ The agent successfully demonstrated:', 'green');
  log('   ‚úì Self-modification (created marker file)', 'green');
  log('   ‚úì Git workflow automation (add, commit, push)', 'green');
  log('   ‚úì Autonomous deployment to GitHub', 'green');
  log('\n   üöÄ The agent can autonomously deploy changes to itself!', 'bright');
} else {
  log('\n‚ö†Ô∏è  Deployment incomplete - check details above', 'yellow');
}

// Save final report
await fs.writeFile(
  path.join(RESULTS_DIR, 'final-report.json'),
  JSON.stringify(report, null, 2)
);

log(`\nüìÅ Results saved to: ${RESULTS_DIR}/`, 'cyan');
log('   ‚Ä¢ phase1-tools.json', 'cyan');
log('   ‚Ä¢ phase2-deployment.json', 'cyan');
log('   ‚Ä¢ final-report.json', 'cyan');

console.log('\n' + '='.repeat(80) + '\n');

process.exit(report.overall_success ? 0 : 1);
