"""Forgekeeper navigation CLI.

This command line interface inspects the cached JSON artifacts generated by
``tools/nav/build_module_index.py`` (Task N1) and
``tools/nav/export_dependencies.py`` (Task N2). It exposes quick lookups for
Python modules as well as frontend/backed dependency relationships.

Example usage::

    python -m tools.nav list-modules --package forgekeeper
    python -m tools.nav show-module forgekeeper.change_stager
    python -m tools.nav related-files task_pipeline

Shell completions are available via::

    python -m tools.nav --print-completion bash

Evaluating the resulting snippet installs a lightweight completion function for
``bash`` or ``zsh``.
"""

from __future__ import annotations

import argparse
import json
import re
import sys
import textwrap
from dataclasses import dataclass
from pathlib import Path
from typing import Iterable, Iterator, List, Mapping, Optional, Sequence

MODULE_INDEX_CANDIDATES = (
    Path("module_index.json"),
    Path(".forgekeeper/cache/module_index.json"),
)
PYTHON_GRAPH_CANDIDATES = (Path(".forgekeeper/cache/python_import_graph.json"),)
FRONTEND_GRAPH_CANDIDATES = (
    Path(".forgekeeper/cache/frontend_dependency_graph.json"),
)
BACKEND_GRAPH_CANDIDATES = (Path(".forgekeeper/cache/backend_dependency_graph.json"),)


class NavigationDataError(RuntimeError):
    """Raised when expected navigation artifacts are missing or malformed."""


@dataclass
class CLIState:
    root: Path
    module_index_override: Optional[Path] = None
    python_graph_override: Optional[Path] = None
    frontend_graph_override: Optional[Path] = None
    backend_graph_override: Optional[Path] = None
    module_index_path: Optional[Path] = None
    python_graph_path: Optional[Path] = None
    frontend_graph_path: Optional[Path] = None
    backend_graph_path: Optional[Path] = None
    module_index: Optional[Mapping[str, object]] = None
    python_graph: Optional[Mapping[str, object]] = None
    frontend_graph: Optional[Mapping[str, object]] = None
    backend_graph: Optional[Mapping[str, object]] = None

    def locate_path(self, override: Optional[Path], candidates: Sequence[Path]) -> Optional[Path]:
        if override:
            return override if override.is_absolute() else (self.root / override)
        for candidate in candidates:
            absolute = candidate if candidate.is_absolute() else (self.root / candidate)
            if absolute.exists():
                return absolute
        return None

    def resolve_module_index_path(self) -> Path:
        if self.module_index_path is None:
            path = self.locate_path(self.module_index_override, MODULE_INDEX_CANDIDATES)
            if not path or not path.exists():
                raise NavigationDataError(
                    "Unable to locate module_index.json. Run `make module-index` first or provide --module-index."
                )
            self.module_index_path = path
        return self.module_index_path

    def resolve_python_graph_path(self) -> Path:
        if self.python_graph_path is None:
            path = self.locate_path(self.python_graph_override, PYTHON_GRAPH_CANDIDATES)
            if not path or not path.exists():
                raise NavigationDataError(
                    "Unable to locate python_import_graph.json. Run `python tools/nav/export_dependencies.py` or provide --python-graph."
                )
            self.python_graph_path = path
        return self.python_graph_path

    def resolve_frontend_graph_path(self) -> Path:
        if self.frontend_graph_path is None:
            path = self.locate_path(self.frontend_graph_override, FRONTEND_GRAPH_CANDIDATES)
            if not path or not path.exists():
                raise NavigationDataError(
                    "Unable to locate frontend_dependency_graph.json. Run `python tools/nav/export_dependencies.py` or provide --frontend-graph."
                )
            self.frontend_graph_path = path
        return self.frontend_graph_path

    def resolve_backend_graph_path(self) -> Path:
        if self.backend_graph_path is None:
            path = self.locate_path(self.backend_graph_override, BACKEND_GRAPH_CANDIDATES)
            if not path or not path.exists():
                raise NavigationDataError(
                    "Unable to locate backend_dependency_graph.json. Run `python tools/nav/export_dependencies.py` or provide --backend-graph."
                )
            self.backend_graph_path = path
        return self.backend_graph_path


def load_json(path: Path, description: str) -> Mapping[str, object]:
    try:
        with path.open("r", encoding="utf-8") as handle:
            return json.load(handle)
    except FileNotFoundError as exc:
        raise NavigationDataError(f"Missing {description} at {path}") from exc
    except json.JSONDecodeError as exc:
        raise NavigationDataError(f"Failed to parse {description} at {path}: {exc}") from exc


def get_module_index(state: CLIState) -> Mapping[str, object]:
    if state.module_index is None:
        path = state.resolve_module_index_path()
        state.module_index = load_json(path, "module index")
    return state.module_index


def get_python_graph(state: CLIState) -> Mapping[str, object]:
    if state.python_graph is None:
        path = state.resolve_python_graph_path()
        state.python_graph = load_json(path, "python import graph")
    return state.python_graph


def get_frontend_graph(state: CLIState) -> Mapping[str, object]:
    if state.frontend_graph is None:
        path = state.resolve_frontend_graph_path()
        state.frontend_graph = load_json(path, "frontend dependency graph")
    return state.frontend_graph


def get_backend_graph(state: CLIState) -> Mapping[str, object]:
    if state.backend_graph is None:
        path = state.resolve_backend_graph_path()
        state.backend_graph = load_json(path, "backend dependency graph")
    return state.backend_graph


def iter_index_modules(index: Mapping[str, object]) -> Iterator[Mapping[str, object]]:
    packages = index.get("packages", [])
    if isinstance(packages, list):
        for package in packages:
            if not isinstance(package, Mapping):
                continue
            pkg_name = package.get("name")
            pkg_path = package.get("path")
            if isinstance(pkg_name, str) and isinstance(pkg_path, str):
                yield {
                    "name": pkg_name,
                    "path": str(Path(pkg_path) / "__init__.py"),
                    "docstring": package.get("docstring"),
                    "classes": [],
                    "functions": [],
                }
            modules = package.get("modules", []) or []
            if isinstance(modules, list):
                for module in modules:
                    if isinstance(module, Mapping) and "name" in module:
                        yield module
    standalone = index.get("standalone_modules", [])
    if isinstance(standalone, list):
        for module in standalone:
            if isinstance(module, Mapping) and "name" in module:
                yield module


def module_summary(module: Mapping[str, object]) -> str:
    doc = module.get("docstring")
    if isinstance(doc, str):
        stripped = doc.strip()
        if stripped:
            return stripped.splitlines()[0]
    return ""


def list_modules(state: CLIState, args: argparse.Namespace, stdout) -> int:
    index = get_module_index(state)
    matches: List[Mapping[str, object]] = []
    for module in iter_index_modules(index):
        name = module.get("name")
        if not isinstance(name, str):
            continue
        if args.package and not name.startswith(args.package):
            continue
        if args.contains and args.contains.lower() not in name.lower():
            continue
        matches.append(module)

    if args.limit is not None:
        matches = matches[: max(args.limit, 0)]

    if not matches:
        stdout.write("No modules matched the provided filters.\n")
        return 0

    for module in matches:
        name = module.get("name", "<unknown>")
        path = module.get("path", "?")
        summary = module_summary(module)
        if summary:
            stdout.write(f"{name} -> {path} | {summary}\n")
        else:
            stdout.write(f"{name} -> {path}\n")
    return 0


def show_module(state: CLIState, args: argparse.Namespace, stdout) -> int:
    index = get_module_index(state)
    target = None
    for module in iter_index_modules(index):
        if module.get("name") == args.name:
            target = module
            break

    if not target:
        raise NavigationDataError(f"Module '{args.name}' not found in module_index.json")

    path = target.get("path", "?")
    stdout.write(f"Module: {args.name}\n")
    stdout.write(f"Path: {path}\n")
    doc = target.get("docstring")
    if isinstance(doc, str) and doc.strip():
        stdout.write("\nDocstring:\n")
        stdout.write(textwrap.indent(doc.strip(), "  ") + "\n")
    classes = [cls.get("name") for cls in target.get("classes", []) if isinstance(cls, Mapping)]
    functions = [fn.get("name") for fn in target.get("functions", []) if isinstance(fn, Mapping)]
    if classes:
        stdout.write("\nClasses:\n")
        for cls_name in classes:
            stdout.write(f"  - {cls_name}\n")
    if functions:
        stdout.write("\nFunctions:\n")
        for fn_name in functions:
            stdout.write(f"  - {fn_name}\n")
    return 0


def ts_matches(graph: Mapping[str, object], pattern: re.Pattern[str]) -> Iterable[str]:
    status = graph.get("status")
    if status and status != "ok":
        message = graph.get("message")
        yield f"Graph unavailable ({status}): {message or 'no additional detail'}"
        return
    files = graph.get("files")
    if isinstance(files, Mapping):
        for file_name, deps in files.items():
            haystack = [str(file_name)]
            if isinstance(deps, list):
                haystack.extend(str(dep) for dep in deps)
            if any(pattern.search(item) for item in haystack):
                summary = ", ".join(sorted(str(dep) for dep in deps)) if isinstance(deps, list) else ""
                if summary:
                    yield f"- {file_name}: {summary}"
                else:
                    yield f"- {file_name}"


def related_files(state: CLIState, args: argparse.Namespace, stdout, stderr) -> int:
    compiled = re.compile(args.pattern, re.IGNORECASE)
    python_graph = get_python_graph(state)
    modules = python_graph.get("modules")
    any_output = False
    if isinstance(modules, Mapping):
        python_matches: List[str] = []
        for module_name, payload in modules.items():
            if not isinstance(payload, Mapping):
                continue
            haystack: List[str] = [str(module_name)]
            path = payload.get("path")
            if isinstance(path, str):
                haystack.append(path)
            imports = payload.get("imports")
            if isinstance(imports, list):
                haystack.extend(str(dep) for dep in imports)
            if any(compiled.search(item) for item in haystack):
                internal = payload.get("internal") or []
                internal_str = ", ".join(str(dep) for dep in internal if isinstance(dep, str))
                if internal_str:
                    python_matches.append(f"- {module_name} ({path}) -> {internal_str}")
                else:
                    python_matches.append(f"- {module_name} ({path})")
        if python_matches:
            any_output = True
            stdout.write("Python modules:\n")
            for line in python_matches:
                stdout.write(line + "\n")

    if not args.no_frontend:
        try:
            frontend_graph = get_frontend_graph(state)
        except NavigationDataError as exc:
            print(str(exc), file=stderr)
        else:
            frontend = frontend_graph.get("graph")
            if isinstance(frontend, Mapping):
                lines = list(ts_matches(frontend, compiled))
                if lines:
                    any_output = True
                    stdout.write("\nFrontend dependencies:\n")
                    for line in lines:
                        stdout.write(line + "\n")

    if not args.no_backend:
        try:
            backend_graph = get_backend_graph(state)
        except NavigationDataError as exc:
            print(str(exc), file=stderr)
        else:
            backend = backend_graph.get("graph")
            if isinstance(backend, Mapping):
                lines = list(ts_matches(backend, compiled))
                if lines:
                    any_output = True
                    stdout.write("\nBackend dependencies:\n")
                    for line in lines:
                        stdout.write(line + "\n")

    if not any_output:
        stdout.write("No related files matched the provided pattern.\n")
    return 0


def generate_completion(shell: str) -> str:
    global_opts = "--root --module-index --python-graph --frontend-graph --backend-graph --print-completion"
    command_opts = {
        "list-modules": "--package -p --contains -c --limit",
        "show-module": "",
        "related-files": "--no-frontend --no-backend",
    }
    commands = " ".join(command_opts)

    if shell == "bash":
        return textwrap.dedent(
            f"""
            _forgekeeper_nav_complete() {{
                local cur prev words cword
                _init_completion || return
                if [[ $cword -eq 1 ]]; then
                    COMPREPLY=( $(compgen -W "{commands}" -- "$cur") )
                    return
                fi
                local cmd=${{words[1]}}
                local opts="{global_opts}"
                case "$cmd" in
                    list-modules)
                        opts+=" {command_opts['list-modules']}"
                        ;;
                    show-module)
                        opts+=" {command_opts['show-module']}"
                        ;;
                    related-files)
                        opts+=" {command_opts['related-files']}"
                        ;;
                esac
                COMPREPLY=( $(compgen -W "$opts" -- "$cur") )
            }}
            complete -F _forgekeeper_nav_complete nav
            complete -F _forgekeeper_nav_complete forgekeeper-nav
            """
        ).strip() + "\n"
    if shell == "zsh":
        return textwrap.dedent(
            f"""
            _forgekeeper_nav_complete() {{
                local -a commands
                commands=({commands})
                if (( CURRENT == 2 )); then
                    _describe 'commands' commands
                    return
                fi
                local opts="{global_opts}"
                case $words[2] in
                    list-modules)
                        opts+=" {command_opts['list-modules']}"
                        ;;
                    show-module)
                        opts+=" {command_opts['show-module']}"
                        ;;
                    related-files)
                        opts+=" {command_opts['related-files']}"
                        ;;
                esac
                _arguments '*:: :->args'
                compadd -- $opts
            }}
            compdef _forgekeeper_nav_complete nav forgekeeper-nav
            """
        ).strip() + "\n"
    raise NavigationDataError(f"Unsupported shell for completion: {shell}")


def build_parser() -> argparse.ArgumentParser:
    parser = argparse.ArgumentParser(
        prog="python -m tools.nav",
        description="Inspect Forgekeeper navigation artifacts.",
    )
    parser.add_argument(
        "--root",
        type=Path,
        default=Path.cwd(),
        help="Repository root containing module_index.json and .forgekeeper/cache/.",
    )
    parser.add_argument("--module-index", type=Path, help="Override path to module_index.json.")
    parser.add_argument("--python-graph", type=Path, help="Override path to python_import_graph.json.")
    parser.add_argument("--frontend-graph", type=Path, help="Override path to frontend_dependency_graph.json.")
    parser.add_argument("--backend-graph", type=Path, help="Override path to backend_dependency_graph.json.")
    parser.add_argument(
        "--print-completion",
        choices=("bash", "zsh"),
        help="Print shell completion script for the requested shell and exit.",
    )

    subparsers = parser.add_subparsers(dest="command")

    list_parser = subparsers.add_parser("list-modules", help="List modules from module_index.json")
    list_parser.add_argument("--package", "-p", help="Filter modules by dotted package prefix.")
    list_parser.add_argument("--contains", "-c", help="Filter modules whose name contains this substring.")
    list_parser.add_argument("--limit", type=int, help="Limit the number of results displayed.")
    list_parser.set_defaults(func=list_modules)

    show_parser = subparsers.add_parser("show-module", help="Show details for a specific module")
    show_parser.add_argument("name", help="Fully-qualified module name to inspect.")
    show_parser.set_defaults(func=show_module)

    related_parser = subparsers.add_parser("related-files", help="Search dependency graphs for a pattern")
    related_parser.add_argument("pattern", help="Substring or regex to search for.")
    related_parser.add_argument("--no-frontend", action="store_true", help="Skip the frontend dependency graph.")
    related_parser.add_argument("--no-backend", action="store_true", help="Skip the backend dependency graph.")
    related_parser.set_defaults(func=related_files)

    return parser


def main(argv: Optional[Sequence[str]] = None, *, stdout=None, stderr=None) -> int:
    if stdout is None:
        stdout = sys.stdout
    if stderr is None:
        stderr = sys.stderr

    parser = build_parser()
    args = parser.parse_args(argv)

    if args.print_completion:
        stdout.write(generate_completion(args.print_completion))
        return 0

    if not args.command:
        parser.print_help(file=stdout)
        return 0

    state = CLIState(
        root=args.root.resolve(),
        module_index_override=args.module_index,
        python_graph_override=args.python_graph,
        frontend_graph_override=args.frontend_graph,
        backend_graph_override=args.backend_graph,
    )

    func = getattr(args, "func", None)
    if func is None:
        parser.print_help(file=stdout)
        return 0

    try:
        if func is related_files:
            return func(state, args, stdout, stderr)
        return func(state, args, stdout)
    except NavigationDataError as exc:
        print(str(exc), file=stderr)
        return 1


if __name__ == "__main__":
    raise SystemExit(main())
